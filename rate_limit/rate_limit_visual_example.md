# 滑动窗口限流可视化示例

## 场景：限制每秒100个请求

### 固定窗口 vs 滑动窗口对比

#### 固定窗口的问题

```
时间轴：    0.0秒        0.5秒        1.0秒        1.5秒        2.0秒
          |-----------窗口1-----------|-----------窗口2-----------|
请求分布：
  0.9秒: ████████████████████████████████ (50个请求)
  1.1秒:                                    ████████████████████████████████ (50个请求)

问题：在0.9秒到1.1秒之间（仅0.2秒），实际来了100个请求！
     但固定窗口认为这是两个窗口，都允许通过。
```

#### 滑动窗口的解决方案

```
时间轴：    0.0秒        0.5秒        1.0秒        1.5秒        2.0秒
          
滑动窗口（窗口大小1秒）：
  0.9秒: |<--窗口[0.0-0.9]-->|  (50个请求，允许)
  1.0秒: |<--窗口[0.0-1.0]-->|  (50个请求，允许)
  1.1秒:    |<--窗口[0.1-1.1]-->|  (50个请求，允许)
  1.2秒:       |<--窗口[0.2-1.2]-->|  (50个请求，允许)

关键：窗口是滑动的，始终统计最近1秒内的请求数
```

## 详细示例：Redis ZSet滑动窗口

### 请求序列

假设限制：每秒3个请求

```
时间    操作                    ZSet内容                    结果
0.0秒   请求1                  [0.0]                      ✅ 允许 (1/3)
0.3秒   请求2                  [0.0, 0.3]                 ✅ 允许 (2/3)
0.6秒   请求3                  [0.0, 0.3, 0.6]            ✅ 允许 (3/3)
0.7秒   请求4                  [0.0, 0.3, 0.6]            ❌ 拒绝 (3/3，已满)
1.0秒   请求5                  [0.3, 0.6, 1.0]            ✅ 允许 (3/3)
        说明：删除0.0（已过期），添加1.0
1.1秒   请求6                  [0.3, 0.6, 1.0, 1.1]       ❌ 拒绝 (4/3，超限)
        说明：0.3还在窗口内（1.1-1.0=0.1 < 1秒）
1.2秒   请求7                  [0.6, 1.0, 1.1, 1.2]       ❌ 拒绝 (4/3，超限)
        说明：0.6还在窗口内（1.2-0.6=0.6 < 1秒）
1.3秒   请求8                  [1.0, 1.1, 1.2, 1.3]       ❌ 拒绝 (4/3，超限)
1.4秒   请求9                  [1.1, 1.2, 1.3, 1.4]       ❌ 拒绝 (4/3，超限)
1.5秒   请求10                 [1.2, 1.3, 1.4, 1.5]       ❌ 拒绝 (4/3，超限)
1.6秒   请求11                 [1.3, 1.4, 1.5, 1.6]       ❌ 拒绝 (4/3，超限)
1.7秒   请求12                 [1.4, 1.5, 1.6, 1.7]       ❌ 拒绝 (4/3，超限)
1.8秒   请求13                 [1.5, 1.6, 1.7, 1.8]       ❌ 拒绝 (4/3，超限)
1.9秒   请求14                 [1.6, 1.7, 1.8, 1.9]       ❌ 拒绝 (4/3，超限)
2.0秒   请求15                 [1.7, 1.8, 1.9, 2.0]       ❌ 拒绝 (4/3，超限)
2.1秒   请求16                 [1.8, 1.9, 2.0, 2.1]       ❌ 拒绝 (4/3，超限)
2.2秒   请求17                 [1.9, 2.0, 2.1, 2.2]       ❌ 拒绝 (4/3，超限)
2.3秒   请求18                 [2.0, 2.1, 2.2, 2.3]       ❌ 拒绝 (4/3，超限)
2.4秒   请求19                 [2.1, 2.2, 2.3, 2.4]       ❌ 拒绝 (4/3，超限)
2.5秒   请求20                 [2.2, 2.3, 2.4, 2.5]       ❌ 拒绝 (4/3，超限)
...
```

**关键观察**：
- 在1.0秒时，窗口是[0.0-1.0]，包含3个请求（0.0, 0.3, 0.6）
- 在1.1秒时，窗口是[0.1-1.1]，但0.3还在窗口内（1.1-0.3=0.8 < 1秒）
- 所以窗口内始终有4个请求（0.3, 0.6, 1.0, 1.1），超过限制3

## Lua脚本执行流程

### 步骤1：清理过期数据

```lua
-- 当前时间：1.1秒
-- 窗口大小：1秒
-- 删除时间戳 < (1.1 - 1) = 0.1 的数据

ZREMRANGEBYSCORE key 0 0.1
-- 删除：0.0（已过期）
-- 保留：0.3, 0.6, 1.0（在窗口内）
```

### 步骤2：统计窗口内请求数

```lua
ZCARD key
-- 返回：3（0.3, 0.6, 1.0）
```

### 步骤3：判断是否允许

```lua
if count < limit then  -- 3 < 3? false
    -- 不允许，不添加
    return {0, 3}  -- 拒绝，当前计数3
else
    return {0, 3}  -- 拒绝
end
```

## 实际使用示例

```go
// 秒杀场景：限制每个商品每秒1000个请求
allowed, count, err := CheckRateLimitSlidingWindow(ctx, goodsId, 1000, 1)
if err != nil {
    // 处理错误
    return err
}

if !allowed {
    // 超过限制，拒绝请求
    return errors.New("请求过于频繁，请稍后重试")
}

// 允许请求，继续处理
// count 是当前窗口内的请求数，可用于监控
```

## 性能优化建议

1. **使用Lua脚本**：保证原子性，避免竞态条件
2. **设置过期时间**：自动清理过期数据，避免内存泄漏
3. **批量操作**：如果需要对多个商品限流，可以使用Pipeline
4. **监控告警**：监控限流触发率，及时调整限流阈值

## 总结

滑动窗口限流的核心思想：
1. **窗口是滑动的**：始终统计最近N秒内的请求
2. **自动清理过期数据**：使用ZREMRANGEBYSCORE删除窗口外的数据
3. **原子操作**：使用Lua脚本保证操作的原子性
4. **精确控制**：相比固定窗口，能更精确地控制流量

